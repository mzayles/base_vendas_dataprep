# -*- coding: utf-8 -*-
"""003_DATA-PREP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18uzM4DxkDOnIr5zUxF9dme9YXuRZfQ6-

# **DATAPREP**

Preparação e tratamento de dados (DataPrep)
    Alta probabilidade de erros

    - Valores faltantes: valores nulos
    - Valores duplicados
    - Conversão de tipos de dados (int, float, object ou string, bool)
    - Transposição (colunas --> linhas; linhas --> colunas)

    Identificando problemas na base de dados
    - Valores faltantes: coluna comissão
    - Tipo de dados: valor unitario (string > float)
                     datas venda e entrega (string > date)
    - Padrão no nome das colunas
    - Transposição de colunas para linhas
"""

import pandas as pd
import numpy as np

df = pd.read_csv('base_vendas.csv')

df.tail()

# 3000 linhas e 14 colunas

qtd_linhas = df.shape[0]
qtd_colunas = df.shape[1]

qtd_linhas, qtd_colunas

# preco_custo, valor_unitario, comissao > converter para float
# dt_venda, dt_entrega > converter para datatime

df.info()

df.describe().round(1)

df.describe(include = object)

# nome das colunas não está padronizado
# colunas: 'Nome Funcionario', 'Cargo', 'Categoria"

df.columns

# 2841 valores nulos
# comissão com 94.7% de valores faltantes

df.isnull().sum()
df.isnull().sum() /qtd_linhas * 100

# nenhum dado duplicado
df.duplicated().sum()

""" Objetivo: solucionar os problemas identificados """

# padronização no nome das colunas
df.columns

colunas = ['matricula_funcionario', 'nome_funcionario', 'cargo', 'codigo_loja',
       'nome_loja', 'codigo_produto', 'descricao_produto', 'categoria',
       'preco_custo', 'valor_unitario', 'quantidade', 'comissao', 'dt_venda',
       'dt_entrega']

df.columns = colunas
df.columns

# conversão de tipos de dados
df.info()

# convertendo int em string - uma coluna por vez

df.matricula_funcionario = df.matricula_funcionario.astype('str')
df.info()

# convertendo string em float
# valor_unitario, preco_custo e comissao
# converter mais de um valor na mesma execução
# dicionário - dict
# problema identificado: vírgula como separador de casa decimal
# substituir vírgula por ponto

df['valor_unitario'] = df['valor_unitario'].str.replace(',', '.')
df['preco_custo'] = df['preco_custo'].str.replace(',', '.')
df['comissao'] = df['comissao'].str.replace(',', '.')

df.valor_unitario

df = df.astype(
    {
        'valor_unitario': np.float64,
        'preco_custo': np.float64,
        'comissao': np.float64
    }
)

df.info()

# tratamento de datas - convertendo strings para datetime
# placeholder %: localizar a parte da data
# y: dois dígitos e Y: quatro dígitos

df['dt_venda'] = pd.to_datetime(df['dt_venda'], format='%d/%m/%Y %H:%M')
df['dt_entrega'] = pd.to_datetime(df['dt_entrega'], format='%d/%m/%Y %H:%M')

df.dt_venda

df.dt_entrega

# acessando as partes de uma data
# dt.day, dt.month, dt.hour, dt.minute

df['dt_venda'].dt.year

"""
    Engenharia de atributos (Feauture Engineering)

    - Tratar dados faltantes
    - Eliminar atributos
    - Adicionar atributos
    - Eliminar outliers (muito afastado do comum; elevado; min e max)
    - Padronizar variáveis numéricas
    - Tratar variáveis categóricas (faixa etária de idade)
"""

# identificar e tratar valores faltantes (missing values)
df.head()

# total de valores faltantes por coluna
df.isnull().sum() / df.shape[0] * 100

# método fillna(): onde encontrar valores faltantes, preenche com X, não importa a coluna, ele vai colocar valor se o campo estiver vazio.
# método fill(): pega um valor de referência e vai replicando até encontrar o próximo valor e fazer o mesmo.

df.comissao.ffill()

# método bfill()
# pega um valor de referência de baixo e vai replicando pra cima até encontrar o próximo valor e fazer o mesmo.

df.comissao.bfill()

# apagar
# não altera o dataframe se o inplace não for True

df.drop(columns=['comissao'])

# apagar as linhas com valores faltantes
df.dropna()

# apagar a linha inteira da coluna com valores faltantes
df.dropna(axis='columns')

# uma forma um pouco melhor de substituir os dados faltantes pelo valor médio da variável
df['comissao'].fillna(df['comissao'].mean().round(2)) # média

# criando uma coluna no dataframe

df['valor_total'] = df['quantidade'] * df['valor_unitario']
df.head()

# ordenar por ordem alfábetica e valor do menor para o maior
# categoria: True > A - Z
# valor_total: False > maior - menor

df.sort_values(['categoria', 'valor_total'], ascending=[True, False], inplace=True)
df.head()

df.duplicated().sum()

# duplicidade nem sempre vai ser um problema
df['categoria'].duplicated().sum()

df['categoria'].value_counts()

df.drop_duplicates()
df['categoria'].duplicated().sum()
